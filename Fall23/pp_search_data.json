[{"url":"cheatsheets/","title":"Cheatsheets","tags":["welcome"],"text":"Cheatsheets Getting Started with Julia - live . Fastrack to Julia  cheatsheet. MATLAB-Julia-Python comparative cheatsheet  by  QuantEcon group Plots.jl cheatsheet"},{"url":".","title":"index","tags":["homepage"],"text":""},{"url":"installation/","title":"Software Installation","tags":["welcome"],"text":"First-time setup: Installiere Julia & Pluto Video Version: Text und Bilder Version: Schritt 1: Installiere Julia  1.8.2 Gehe auf  https://julialang.org/downloads  und downloade die momentan stabile Version, Julia  1.8.2 . Achte auf die korrekte Version f√ºr dein Betriebssystem (Linux x86, Mac, Windows, etc). Bei Mac: Zus√§tzlich beachten ob du einen M-Prozessor besitzt oder ein Intel-Prozessor (F√ºr Info: Apple-Symbol ‚Äì> √úber diesen Mac). Schritt 2: Run Julia Nach der Installation,  stelle sicher, dass du Julia ausf√ºhren kannst . Auf manchen Systemen, ist dies verkn√ºpft mit der einfachen Suche nach dem Programm ‚ÄúJulia  1.8.2 ‚Äù und anschlie√üenden ausf√ºhren; in anderen, musst du den Befehl  julia  im Terminal eingeben. Nach der Ausf√ºhrung stelle sicher, dass  1 + 1  tats√§chlich  2  ist: Schritt 3: Installiere  Pluto Als n√§chstes installieren wir  Pluto , eine Notebook Umgebung die wir im Laufe des Praktikas nutzen werden. Pluto ist eine Julia  Programmierumgebung  die extra f√ºr Interaktivit√§t und schnelle Experimente von  **\nFons van der Plas**  entwickelt wurde. √ñffne das  Julia REPL . Dies ist ein command-line interface f√ºr Julia, siehe auch den vorherigen Screenshot. Hier kannst du  Julia Kommandos , eintippen und anschlie√üend ENTER dr√ºcken, dann l√§uft es, und du siehst das Resultat. Um Pluto zu installieren, m√ºssen wir ein  package manager command  eingeben. Um vom  Julia  Modus zum  Pkg  Modus zu wechslen tippe  ]  (geschlossene eckige Klammer) nachdem  julia>  Feld: \njulia> ]\n\n(@v 1.8 ) pkg>\n Die Zeile wird nun blau gef√§rbt sein und das linke Feld wechselt zu  pkg> , was andeutet, dass du dich im  package manager mode  befindest. Dieser Modus erlaubt es dir Operationen auf  packages  (auch libraries, oder deutsch Pakete genannt) auszuf√ºhren. Um Pluto zu installieren, f√ºhre das folgende (sensibel auf Gro√ü-/Kleinschreibung) Kommando aus  add  (install). Du solltest dies nur einmal pro Installtion von Julia machen m√ºssen. \n(@v 1.8 ) pkg> add Pluto\n Dies k√∂nnte einige Minuten in Anspruch nehmen, zuh√∂ren und Kaffee trinken! Du kannst nun das Terminal schlie√üen. Schritt 4: Nutze modernen browser: Mozilla Firefox / Google Chrome Firefox und Chrome sind f√ºr diesen Kurs bzw. Pluto Notebooks am besten geeignet. Zweite Mal:  F√ºhre Pluto aus & √∂ffne ein Pluto-Notebook Wiederhole die folgenden Schritte, wenn du an einen Projekt oder deinen Aufgabenblatt arbeiten m√∂chtest. Schritt 1: Starte Pluto Starte die Julia REPL, wie du es auch schon bei dem first-time setup getan hast. Im REPL tippe: julia> import Pluto; using Pluto\n\njulia> Pluto.run()\n Das Terminal wird dir dann sagen zu  http://localhost:1234/  (oder √§hnliche URL) zu gehen. Lasst uns also Firefox oder Chrome √∂ffnen und f√ºgt die URL in die Adressbar ein. Schritt 2a: √ñffne ein Notebook aus dem Web This is the main menu - here you can create new notebooks, or open existing ones. Our homework assignments will always be based on a  template notebook , available in this GitHub repository. To start from a template notebook on the web, you can  paste the URL into the blue box  and press ENTER. For example, homework 0 is available  here . Go to this page, and on the top right, click on the button that says ‚ÄúEdit or run this notebook‚Äù. From these instructions, copy the notebook link, and paste it into the box. Press ENTER, and select OK in the confirmation box. The first thing we will want to do is to save the notebook somewhere on our own computer; see below. Step 2b: Opening an existing notebook file When you launch Pluto for the second time, your recent notebooks will appear in the main menu. You can click on them to continue where you left off. If you want to run a local notebook file that you have not opened before, then you need to enter its  full path  into the blue box in the main menu. More on finding full paths in step 3. Step 3: Saving a notebook We first need a folder to save our homework in. Open your file explorer and create one. Next, we need to know the  absolute path  of that folder. Here‚Äôs how you do that in  Windows ,  MacOS  and  Ubuntu . For example, you might have: C:\\Users\\fons\\Documents\\18S191_assignments\\  on Windows /Users/fons/Documents/18S191_assignments/  on MacOS /home/fons/Documents/18S191_assignments/  on Ubuntu Now that we know the absolute path, go back to your Pluto notebook, and at the top of the page, click on  ‚ÄúSave notebook‚Ä¶‚Äù . This is where you type the  new path+filename for your notebook : Click  Choose . Step 4: Sharing a notebook After working on your notebook (your code is autosaved when you run it), you will find your notebook file in the folder we created in step 3. This the file that you can share with others, or submit as your homework assignment to Canvas. \nconst run = f => f();\nrun(async () => {\nconst versions = await (await fetch(`https://julialang-s3.julialang.org/bin/versions.json`)).json()\nconst version_names = Object.keys(versions).sort().reverse()\nconst stable = version_names.find(v => versions[v].stable)\nconsole.log({stable})\nconst pkg_stable = /\\d+\\.\\d+/.exec(stable)[0]\ndocument.querySelectorAll(\"auto-julia-version\").forEach(el => {\n    console.log(el)\n    el.innerText = el.getAttribute(\"short\") == null ? stable : pkg_stable\n})\n});"},{"url":"search/","title":"Search results","tags":[],"text":"window.init_search(); Search Results \nLoading..."},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict main \"Willkommen\" collections \"welcome\" .pages, \"Einf√ºhrung\" collections \"preliminaries\" .pages, \"Aufgabenbl√§tter\" collections \"module2\" .pages, \"Module 3 Climate Science\" collections \"module3\" .pages, , about Dict authors name \"Prof. Jens Starke\", url \"http www.jstarke.eu\" , name \"Hannes Wallner\", url \"https github.com HaneWall\" , title \"CAS Julia\", subtitle \"Eine interaktive Einf√ºhrung\", term \"Winter 2023 2024\", institution \"Universit√§t Rostock\", institution url \"http www.uni rostock.de\", institution logo \"black logo uni julia.svg\", institution logo darkmode \"white logo uni julia.svg\" "},{"url":"data_science/discrete_and_continuous/","title":"Discrete and Continuous","tags":["lecture","module2"],"text":" A Pluto.jl notebook v0.19.26 frontmatter chapter 2 video \"https www.youtube.com watch?v H6Dcx3YeTkE\" image \"https user images.githubusercontent.com 6933510 136196552 ce16c06f bd12 427f 80e5 aedb1fbc734a.png\" section 1 order 7 title \"Discrete and Continuous\" layout \"layout.jlhtml\" youtube id \"H6Dcx3YeTkE\" description \"\" tags \"lecture\", \"module2\" using Markdown using InteractiveUtils md\"\"\" Aufgabenblatt f√ºr Woche 1 \"\"\" a 2 "},{"url":"week0/basic_syntax/","title":"Erste Schritte","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.26 frontmatter chapter 1 section 1 order 7 title \"Erste Schritte\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils md\" Erste Schritte in Julia ‚úã Bevor Ihr hier anfangt, solltet Ihr vermutlich zun√§chst Julia installieren und das Package Pluto herunterladen. Eine genaue Anleitung findet Ihr weiter oben unter dem Reiter Software Installation . Ready? üé¨ Dann hier eine kleine Einf√ºhrung \" md\"\"\" Variablen Wir k√∂nnen mithilfe des ` ` Zuweisungsoperators Variablen definieren. Dabei wird immer der linken Variablen der rechte Wert zugewiesen. Einmal festgelegt k√∂nnen wir dann die Gr√∂√üe Variable auch in anderen Zellen nutzen. \"\"\" x 3 y 2x md\"Standardm√§√üig zeigt Pluto Julia die Ausgabe √ºber der ausgef√ºhrten Zelle an. Dies kann man beispielsweise durch ein Semikolon am Ende einer Zeile unterdr√ºcken. Au√üerdem wichtig M√∂chte man mehrere Zeilen hintereinander ausf√ºhren so sollte die Zelle in einer `let ... end` Umgebung eingebunden sein \" let c 2 d 3 e 3c 2d end md\"\"\" Dadurch beschr√§nken wir auch die Sichtbarkeit der Variable c in anderen Zellen. Man definiert die Variablen also lokal in der Zelle `local scope` . Demnach erhalten wir nach Abfrage der Variablen `c` in einer anderen Zelle einen Error. \"\"\" md\"\"\" Um mehrere Zeilen ausf√ºhren zu k√∂nnen und dennoch die Variablen global in allen Zellen bereitzustellen, kann eine `begin ... end` Umgebung genutzt werden. \"\"\" begin h 2 p 3 k 3h 2p end k md\"Mithilfe von `typeof` k√∂nnen wir den Typen einer Variablen abfragen \" typeof y md\"\"\" In diesen Fall ist `y` eine 64Bit Integer Zahl. Es werden demnach 64 Bin√§rzahlen bereitgestellt um die ganze Zahl darzustellen. Dazu eventuell an anderer Stelle mehr... \"\"\" md\" Funktionen\" md\"\"\" H√§ufig braucht man eine bestimmte Prozedur bestimmte Abfolge von Befehlen innerhalb eines Programms immer und immer wieder. Zur F√∂rderung der Lesbarkeit des Codes, aber auch zur Verk√ºrzung ist es dann ratsam Funktionen zu definieren. In Julia gibt es ganz verschiedene M√∂glichkeiten Funktionen zu deklarieren. Hier sind ein paar aufgezeigt, die alle identisch sind \"\"\" f‚ÇÅ x 2 x f‚ÇÇ x x 2 x function f‚ÇÉ x return 2 x end md\"Um eine Funktion aufzurufen und an einer Stelle auszuwerten m√ºssen wir runde Klammern ` ` nutzen.\" f‚ÇÅ 10 md\"F√ºr l√§ngere Funktionen sollte man die Syntax mit den `function` und `end` keyword nutzen. Au√üerdem kann man nat√ºrlich multivariable Funktionen definieren.\" function g x, y z x y return z^2 end g 1, 2 md\" For loops For Schleifen\" md\"\"\" Nutze `for` zum iterieren √ºber ein `Iterator` `Array` `Range` und dessen Variablen. \"\"\" let Dies ist ein Kommentar Kennzeichunng mittels s 0 Summation aller Zahlen von 1 bis 10 for i in 1 10 s i √Ñquivalent zu s s i end s end md\"Hier ist `1 10` eine range welche die Zahlen von 1 bis 10 repr√§sentiert.\" typeof 1 10 md\"\"\" Wir haben gerade einen `let` Block genutzt um eine Variable `s` zu definieren. Dabei w√§re es hier angebracht gewesen eine Funktion `mysum` zu schreiben, welche dann `global` in allen Zellen dieses Notebooks ausgef√ºhrt werden kann \"\"\" function mysum n s 0 for i in 1 n s i end return s end md\"\"\" Jetzt k√∂nnen wir die Funktion in einer anderen Zelle aufrufen. Zum Beispiel k√∂nnen wir die ersten 100 nat√ºrlichen Zahlen aufsummieren \"\"\" mysum 100 md\" Conditionals `if` Bedingungen `if`\" md\"\"\" Wir k√∂nnen auswerten ob eine Bedingung `true` oder `false` ist \"\"\" a 3 a 5 typeof a 5 md\"\"\" Wir sehen, dass Bedingungen einen `Bool` Ausgabetypen `true` oder `false` besitzen. Basierend auf der boolschen Ausgabe einer Bedingung k√∂nnen wir den Ablauf des Codes mit einer `if` `else` `end` Umgebung lenken. \"\"\" if a 5 \"small\" else \"big\" end md\"\"\" Falls diese Verzweigung auch noch nicht gen√ºgt, kann man eine `if elseif else end` Umgebung basteln. \"\"\" if a 2 \"small\" elseif a 2 && a 4 \"intermediate\" else a 4 \"big\" end md\"\"\" Hierbei haben wir Gebrauch von den `&&` Vergleichsoperator gemacht. Dieser vergleicht zwei boolsche Bedingungen links und rechts vom Operator . Sind beide wahr `true` , so ist die Ausgabe abermals `true`. Generell kann man sogar mehrere `elseif` Abfragen in einen solcher Umgebung unterbringen. \"\"\" md\" `Array`s\" md\"\"\" `Array`s sind gewisserma√üen das Fundament der computerorientierten Mathematik. Sie erlauben es uns mehrere Werte zu speichern und auszulesen. \"\"\" md\" 1D `Arrays`\" md\"\"\" Wir k√∂nnen ein eindimensionales `Array` 1 dimensional, oder 1D `Array` durch eckige Klammern ` ` erzeugen. \"\"\" v 1, 3, 5 typeof v md\"\"\" Die `1` im Typen zeigt die Anzahl der Dimensionen. Ausgesprochen `v` ist ein 1D array, welches Elemente vom Typen `Int64` beherbergt. Fundamental bei Arrays Wir k√∂nnen deren Elemente einsehen und √§ndern. Zum Beispiel k√∂nnen wir durch `array index ` uns das Element an der Position `index` des Arrays ausgeben lassen. \"\"\" v 2 md\"\"\" Nat√ºrlich k√∂nnen wir auch das Element an zweiter Stelle √§ndern \"\"\" v 2 10 v md\"\"\" Nett zu wissen und noch h√§ufiger zu gebrauchen \"\"\" md\"\"\" Eine √§u√üerst elegante Art und Weise `Array`s zu erzeugen ist das sogenannte array comprehension Muster. Dabei verbinden wir eine For Schleife mit der Konstruktion eines `Array`s. Z.B. alle Quadratzahlen von 1 bis 10 als 1D `Array` \"\"\" v2 i^2 for i in 1 10 md\"\"\" Die Alternative Zun√§chst erstellen wir ein 10 Elemente langes Array aus Nullen vom Typ `Int64`. \"\"\" v3 zeros Int64, 10 md\"\"\" Anschlie√üend iterieren wir mittels `for` Schleife √ºber die `Indizes` des `Array`s und ver√§ndern die Elemente zu den gew√ºnschten Quadratzahlen. \"\"\" begin for idx in 1 10 v3 idx idx^2 end v3 end md\"\"\" `Array` Slicing \"\"\" md\"\"\" Sagen wir, wir m√∂chten ein St√ºck aus dem ehemaligen `Array` extrahieren. Spezifischer wir m√∂chten ein neues Array `v4` erzeugen welches dem urspr√ºnglichen `v3` vom `Index` 3 bis 7 entspricht Grenzen inkludiert . Dies k√∂nnen wir durch den ` ` Operator innerhalb der eckigen Klammer gew√§hrleisten. \"\"\" v4 v3 3 7 md\"\"\" Ab und an kommt es vor, dass man eventuell nur jedes `n` te Element des urspr√ºnglichen `Array`s ben√∂tigt. Daf√ºr nutzen wir dann die slicing Syntax, bei der wir zwischen den `Start` und `Stop` `Index` zus√§tzlich eine Schrittweite `Step` hinzuf√ºgen. `array Start Step Stop ` . Z.B. nur jedes `2` te Element des Quadratzahlenarrays \"\"\" v5 v3 1 2 10 md\"\"\" Konstruktion von `Arrays` mit festgelegter Schrittweite \"\"\" md\"\"\" Mithilfe der Slicing Syntax k√∂nnen wir in Julia auch `Array`s konstruieren. Zun√§chst bastelt man sich eine range mittels `r Start Step Stop`, diese kann dann anschlie√üend mittels `collect r ` zu einen `Array` umgeformt werden. Zum Beispiel hier die Erzeugung eines 1D `Array`s, dessen Elemente von 1 bis 19 mit einer Schrittweite von 3 reichen. \"\"\" arr collect 1 3 19 md\" 2D `Arrays`\" md\"\"\" 1D `Array`s werden schnell langweilig. Lasst uns nun 2D `Array`s anschauen, die sehr h√§ufig ben√∂tigt werden. Ihr werdet feststellen das mit dem Vorwissen von 1D `Array`s der Sprung zu ND `Array`s nur minimal ist. Man kann auf ganz verschiedene Art und Weisen ein 2D `Array` bzw. eine Matrix erzeugen. Alle sind √§quivalent \"\"\" M 1 2 3 4 M‚ÇÇ 1 2 3 4 md\"\"\" Mittels Spaltenvektoren \"\"\" M‚ÇÉ 1, 3 2, 4 typeof M md\"Die `2` im Typen best√§tigt, dass es sich tats√§chlich um ein 2D `Array` handelt\" md\"\"\" Die Navigation innerhalb eines 2D `Array`s ist identisch zum eindimensionalen Fall. Da wir nun in zwei Dimensionen arbeiten ben√∂tigen wir jedoch f√ºr die Position zwei `Indizes`. Der erste `Index` deklariert die Zeile in der wir arbeiten und der zweite `Index` die Spalte. `array row, column ` bzw. deutsch `array Zeile, Spalte ` \"\"\" M M 1, 1 M 2, 2 md\"\"\" Nat√ºrlich funktioniert auch hier slicing . \"\"\" M 1, 1 2 M 1 2, 2 md\"\"\" Auch hier k√∂nnen wir nat√ºrlich Werte √§ndern. \"\"\" M 1 2, 2 7, 7 M md\"\"\" Vorgefertigte Arrays \"\"\" md\"\"\" F√ºr gro√üe Matrizen ist es wenig sinnvoll, diese per Hand zu definieren. Hier greift man auf bereits vorgefertigte Konstruktionen von Julia zur√ºck. Z.B. k√∂nnen wir eine Matrix ein 2D `Array` voller Nullen durch den Befehl `zeros TYP, Anzahl Zeilen, Anzahl Spalten ` initialisieren. \"\"\" zeros 3, 5 md\"Wenn wir kein TYP angeben, so geht Julia davon aus das wir Gleitkommazahlen `Float64` meinen. M√∂chten wir hingegen ganze Zahlen `Integer` so k√∂nnen wir dies durch den TYP festlegen.\" einmaleins zeros Int64, 5, 5 md\"Jetzt k√∂nnte man mittels zweier in sich gekopppelter `for Schleifen` √ºber die `Indizes` iterieren und somit die Matrix auff√ºllen. Hier z.B. eine 1√ó1 Tabelle bis 5 \" begin for zeilen idx in 1 5 for spalten idx in 1 5 einmaleins zeilen idx, spalten idx zeilen idx spalten idx end end einmaleins end md\"\"\" Das kleine 1√ó1 mittels array comprehension \"\"\" md\"Eine sehr nette und elegante Alternative ist abermals das array comprehension Muster. Hier das 1√ó1 bis 12 durch eine einzige Zeile Code.\" bigeinmaleins zeile spalte for zeile in 1 12, spalte in 1 12 "}]