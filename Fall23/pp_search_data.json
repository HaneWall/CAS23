[{"url":"cheatsheets/","title":"Cheatsheets","tags":["welcome"],"text":"Cheatsheets Schnelleinstieg: Fastrack to Julia  cheatsheet. Übersicht für Befehlsunterschiede zwischen Matlab-Python-Julia: MATLAB-Julia-Python comparative cheatsheet  by  QuantEcon group Makie Plots: Makie.jl Vorlagen"},{"url":".","title":"index","tags":["homepage"],"text":""},{"url":"installation/","title":"Software Installation","tags":["welcome"],"text":"First-time setup: Installiere Julia & Pluto Video Version von Fons (Entwickler von Pluto): Text und Bilder Version: Schritt 1: Installiere Julia  1.8.2 Gehe auf  https://julialang.org/downloads  und downloade die momentan stabile Version, Julia  1.8.2 . Achte auf die korrekte Version für dein Betriebssystem (Linux x86, Mac, Windows, etc). Bei Mac: Zusätzlich beachten ob du einen M-Prozessor besitzt oder ein Intel-Prozessor (Für Info: Apple-Symbol –> Über diesen Mac). Schritt 2: Run Julia Nach der Installation,  stelle sicher, dass du Julia ausführen kannst . Auf manchen Systemen, ist dies verknüpft mit der einfachen Suche nach dem Programm “Julia  1.8.2 ” und anschließenden ausführen; in anderen, musst du den Befehl  julia  im Terminal eingeben. Nach der Ausführung stelle sicher, dass  1 + 1  tatsächlich  2  ist: Schritt 3: Installiere  Pluto Als nächstes installieren wir  Pluto , eine Notebook Umgebung die wir im Laufe des Praktikas nutzen werden. Pluto ist eine Julia  Programmierumgebung  die extra für Interaktivität und schnelle Experimente von  **\nFons van der Plas**  entwickelt wurde. Öffne das  Julia REPL . Dies ist ein command-line interface für Julia, siehe auch den vorherigen Screenshot. Hier kannst du  Julia Kommandos , eintippen und anschließend ENTER drücken, dann läuft es, und du siehst das Resultat. Um Pluto zu installieren, müssen wir ein  package manager command  eingeben. Um vom  Julia  Modus zum  Pkg  Modus zu wechslen tippe  ]  (geschlossene eckige Klammer) nachdem  julia>  Feld: \njulia> ]\n\n(@v 1.8 ) pkg>\n Die Zeile wird nun blau gefärbt sein und das linke Feld wechselt zu  pkg> , was andeutet, dass du dich im  package manager mode  befindest. Dieser Modus erlaubt es dir Operationen auf  packages  (auch libraries, oder deutsch Pakete genannt) auszuführen. Um Pluto zu installieren, führe das folgende (sensibel auf Groß-/Kleinschreibung) Kommando aus  add  (install). Du solltest dies nur einmal pro Installtion von Julia machen müssen. \n(@v 1.8 ) pkg> add Pluto\n Dies könnte einige Minuten in Anspruch nehmen, zuhören und Kaffee trinken! Du kannst nun das Terminal schließen. Schritt 4: Nutze modernen browser: Mozilla Firefox / Google Chrome Firefox und Chrome sind für diesen Kurs bzw. Pluto Notebooks am besten geeignet. Zweite Mal:  Führe Pluto aus & öffne ein Pluto-Notebook Wiederhole die folgenden Schritte, wenn du an einen Projekt oder deinen Aufgabenblatt arbeiten möchtest. Schritt 1: Starte Pluto Starte die Julia REPL, wie du es auch schon bei dem first-time setup getan hast. Im REPL tippe: julia> import Pluto; using Pluto\n\njulia> Pluto.run()\n Das Terminal wird dir dann sagen zu  http://localhost:1234/  (oder ähnliche URL) zu gehen. Lasst uns also Firefox oder Chrome öffnen und fügt die URL in die Adressbar ein. Schritt 2a: Öffne ein Notebook aus dem Web This is the main menu - here you can create new notebooks, or open existing ones. Our homework assignments will always be based on a  template notebook , available in this GitHub repository. To start from a template notebook on the web, you can  paste the URL into the blue box  and press ENTER. For example, homework 0 is available  here . Go to this page, and on the top right, click on the button that says “Edit or run this notebook”. From these instructions, copy the notebook link, and paste it into the box. Press ENTER, and select OK in the confirmation box. The first thing we will want to do is to save the notebook somewhere on our own computer; see below. Step 2b: Opening an existing notebook file When you launch Pluto for the second time, your recent notebooks will appear in the main menu. You can click on them to continue where you left off. If you want to run a local notebook file that you have not opened before, then you need to enter its  full path  into the blue box in the main menu. More on finding full paths in step 3. Step 3: Saving a notebook We first need a folder to save our homework in. Open your file explorer and create one. Next, we need to know the  absolute path  of that folder. Here’s how you do that in  Windows ,  MacOS  and  Ubuntu . For example, you might have: C:\\Users\\fons\\Documents\\18S191_assignments\\  on Windows /Users/fons/Documents/18S191_assignments/  on MacOS /home/fons/Documents/18S191_assignments/  on Ubuntu Now that we know the absolute path, go back to your Pluto notebook, and at the top of the page, click on  “Save notebook…” . This is where you type the  new path+filename for your notebook : Click  Choose . Step 4: Sharing a notebook After working on your notebook (your code is autosaved when you run it), you will find your notebook file in the folder we created in step 3. This the file that you can share with others, or submit as your homework assignment to Canvas. \nconst run = f => f();\nrun(async () => {\nconst versions = await (await fetch(`https://julialang-s3.julialang.org/bin/versions.json`)).json()\nconst version_names = Object.keys(versions).sort().reverse()\nconst stable = version_names.find(v => versions[v].stable)\nconsole.log({stable})\nconst pkg_stable = /\\d+\\.\\d+/.exec(stable)[0]\ndocument.querySelectorAll(\"auto-julia-version\").forEach(el => {\n    console.log(el)\n    el.innerText = el.getAttribute(\"short\") == null ? stable : pkg_stable\n})\n});"},{"url":"search/","title":"Search results","tags":[],"text":"window.init_search(); Search Results \nLoading..."},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict main \"Willkommen\" collections \"welcome\" .pages, \"Grundlagen Julia\" collections \"preliminaries\" .pages, \"Aufgabenblätter\" collections \"assignments\" .pages, \"Vorlesungen\" collections \"lecs\" .pages, \"Module 3 Climate Science\" collections \"module3\" .pages, , about Dict authors name \"Prof. Jens Starke\", url \"http www.jstarke.eu\" , name \"Hannes Wallner\", url \"https github.com HaneWall\" , title \"CAS Julia\", subtitle \"Eine interaktive Einführung\", term \"Winter 2023 2024\", institution \"Universität Rostock\", institution url \"http www.uni rostock.de\", institution logo \"black logo uni julia.svg\", institution logo darkmode \"white logo uni julia.svg\" "},{"url":"whyjulia/","title":"Warum Julia?","tags":["welcome"],"text":"Warum Julia? Hier die eventuell amüsante, aber dennoch ernstzunehmende Beantwortung der Entwickler vom MIT, welche die Sprache 2012 veröffentlichten: Julia Manifest 2012 zum Release der Sprache: In short, because we are greedy. We are power Matlab users. Some of us are Lisp hackers. Some are Pythonistas, others Rubyists, still others Perl hackers. There are those of us who used Mathematica before we could grow facial hair. There are those who still can’t grow facial hair. We’ve generated more R plots than any sane person should. C is our desert island programming language. We love all of these languages; they are wonderful and powerful. For the work we do — scientific computing, machine learning, data mining, large-scale linear algebra, distributed and parallel computing — each one is perfect for some aspects of the work and terrible for others. Each one is a trade-off. We are greedy: we want more. We want a language that’s open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that’s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled. (Did we mention it should be as fast as C?) Das klingt alles sehr hochtrabend - elf Jahre später (quasi noch ein Baby) muss man jedoch sagen, dass es Ihnen im Großen und Ganzen gelungen ist, eine kompetetive Programmiersprache zu entwickeln, die den Tod von zumindest Matlab besiegeln könnte. Warum Julia in diesen Kurs? Im Laufe eures Studiums werdet ihr vorallem in Matlab oder Julia bzw. allgemein mit dem  numerischen  Programmieren in Berührung kommen. Folglich ist es sinnvoll bereits hier mit Julia (bzw. Matlab - nahezu gleiche Syntax) anzufangen. Computeralgebrasysteme wie Maple verfolgen hingegen eine andere Philosophie und versuchen mit symbolischen Umformungen und analytischen Ergebnissen zu glänzen. Definitiv besitzen beide Herangehensweisen ihre Daseinsberechtigung, jedoch haben  numerische  Verfahren deutlich größere Anwendungsbereiche (siehe unten Industrie & Bildung). Ist die Wahl der Programmiersprache endgültig? Nein, keineswegs! Der typische Weg ist in etwa so: Man lernt eine Sprache sehr gut kennen und lernt grundlegende Prinzipien, Muster bzw. Konzepte. In dieser Sprache fängt man dann an Probleme zu lösen und Projekte fürs Studium zu bearbeiten. Über die Zeit werdet Ihr dann durch das Internet, andere Kurse oder Kommilitonen auf andere Programmiersprachen treffen, in der das spezifische Problem noch viel leichter zu lösen ist. Also war dann alles umsonst? Nein! Die Muster und die Syntax sind in allen Sprachen ziemlich nah aneinander. Wenn Ihr den Namen des Musters/Konzepts bzw. der Syntax beherrscht könnt ihr mit einfachen  googlen  eine neue Programmiersprache lernen! Jede weitere Programmiersprache ist dann nur noch Formsache. Das Zwei-Sprachenproblem Innerhalb der Industrie und Forschung gibt es seit vielen Jahrzehnten ein Problem. Häufig möchte man ein Sachverhalt verstehen und simulieren und greift somit zu einer Skriptsprache wie Python, um schnell einen Prototypen zu entwickeln. Funktioniert dieser, wird der gesamte Prototyp in eine performantere, kompilierte Sprache wie C oder Rust umgeschrieben. Dieser Entwicklungsprozess kann sehr lange dauern. Im Laufe der letzten 10 Jahre kam es dann zur einer Popularitätsexplosion von Python, da man eine vermeidliche Lösung für dieses Problem fand. Python war schon immer durch seine kinderleichte Syntax bekannt, ist jedoch selbst äußerst langsam. Aus diesem Grund  schummelt  man in Python etwas und importiert direkt C-Pakete (z.B. NumPy oder Pandas) um seine Berechnungen durchzuführen. Demnach wird Python quasi als leichte Benutzeroberfläche von C genutzt. Man kann sich vorstellen, dass dies erstmal einen ordentlichen Performanceboost mit sich bringt, aber man auch schnell auf Grenzen stößt und nie ganz an die Performance von C herankommt bzw. man einfach nicht die gleiche Flexibilität besitzt, wie bei einen reinen C Projekt.Eine wirklich elegante Lösung ist das also nicht. Hier kommt nun Julia ins Spiel und überzeugt mit ähnlicher Performance zu C, nativen Paketen und einer Syntax die im  Sweetspot  zwischen C, Matlab und Python einzuordnen ist. Julia ist in Julia selbst und C geschrieben und vollständig Open-Source (also auch kostenlos). Dies führt dazu, dass jeder aktiv die Sprache mitgestalten und weiter optimieren kann. Durch die leichte Syntax von Julia können wir also schnell Prototypen erstellen, die dann mittels Optimierung des Codes in der selben Sprache zu einen echten Produkt heranreifen können. Industrie Der größte Vermögensverwalter der Welt  BlackRock  setzt bei seinen Datenanalysesystem  Aladdin  auf Julia. ASML , bekannt durch seine Lithografieverfahren (die es ermöglichen Computerchips herzustellen - Thema der Weltpolitik), wechseln seit zwei Jahren von Matlab und Python zu Julia. Inzwischen hat  ASML  über 130 private Julia Verzeichnisse auf GitHub, natürlich alle streng geheim. Amazon  nutzt Julia für Quantum Computing. Dies ist vermutlich die Zukunft der ganzen, noch sehr jungen Branche, da die hier entwickelten Pakete nur in Julia existieren. Seit 2022 wertet  CERN  Daten vom Large-Hydron-Collider mit Julia aus. Intel, IBM, Apple, NASA  .. sind alle aktive Sponsor der Sprache und adoptieren in bestimmten Bereichen zu Julia. Bildung & Forschung Die große Forschungsgruppe  Modelling Climate Alliance  produziert ein State-of-the-Art Paket für die Simulation des Weltklimas in Julia. Die Verbindung von  Big Data  mit rasanten Algorithmen in Julia, erlaubt es vorallem in der Pharmaindustrie ( Moderna, Pfizer, AstraZeneca ) schneller Medikamente zu entwickeln. Die renomiertesten Universitäten wie z.B. MIT, Stanford, UC Berkeley, Brown, ETH Zurich etc. bieten alle Kurse in Julia an (in Zukunft vllt. auch in Rostock?) Übrigens diese Website wurde auch mit Julia gebaut, cheers Hannes"},{"url":"week_0/arrays/","title":"Arrays","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.26 frontmatter chapter 2 order 2 title \"Arrays\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils using LinearAlgebra using PlutoUI md\" `Array`s\" md\"\"\" `Array`s sind gewissermaßen das Fundament der computerorientierten Mathematik. Sie erlauben es uns mehrere Werte zu speichern und auszulesen. \"\"\" md\" 1D `Arrays`\" md\"\"\" Wir können ein eindimensionales `Array` 1 dimensional, oder 1D `Array` durch eckige Klammern ` ` erzeugen. \"\"\" v 1, 3, 5 typeof v md\"\"\" Die `1` im Typen zeigt die Anzahl der Dimensionen. Ausgesprochen `v` ist ein 1D array, welches Elemente vom Typen `Int64` beherbergt. Fundamental bei Arrays Wir können deren Elemente einsehen und ändern. Zum Beispiel können wir durch `array index ` uns das Element an der Position `index` des Arrays ausgeben lassen. \"\"\" v 2 md\"\"\" Natürlich können wir auch das Element an zweiter Stelle ändern \"\"\" v 2 10 v md\"\"\" `Array` comprehension \"\"\" md\"\"\" Eine äußerst elegante Art und Weise `Array`s zu erzeugen ist das sogenannte array comprehension Muster. Dabei verbinden wir eine For Schleife mit der Konstruktion eines `Array`s. Z.B. alle Quadratzahlen von 1 bis 10 als 1D `Array` \"\"\" v2 i^2 for i in 1 10 md\"\"\" Die Alternative Zunächst erstellen wir ein 10 Elemente langes Array aus Nullen vom Typ `Int64`. \"\"\" v3 zeros Int64, 10 md\"\"\" Anschließend iterieren wir mittels `for` Schleife über die `Indizes` des `Array`s und verändern die Elemente zu den gewünschten Quadratzahlen. \"\"\" begin for idx in 1 10 v3 idx idx^2 end v3 end md\"\"\" `Array` Slicing \"\"\" md\"\"\" Sagen wir, wir möchten ein Stück aus dem ehemaligen `Array` extrahieren. Spezifischer wir möchten ein neues Array `v4` erzeugen welches dem ursprünglichen `v3` vom `Index` 3 bis 7 entspricht Grenzen inkludiert . Dies können wir durch den ` ` Operator innerhalb der eckigen Klammer gewährleisten. \"\"\" v4 v3 3 7 md\"\"\" Ab und an kommt es vor, dass man eventuell nur jedes `n` te Element des ursprünglichen `Array`s benötigt. Dafür nutzen wir dann die slicing Syntax, bei der wir zwischen den `Start` und `Stop` `Index` zusätzlich eine Schrittweite `Step` hinzufügen. `array Start Step Stop ` . Z.B. nur jedes `2` te Element des Quadratzahlenarrays \"\"\" v5 v3 1 2 10 md\"\"\" Konstruktion von `Arrays` mit festgelegter Schrittweite \"\"\" md\"\"\" Mithilfe der Slicing Syntax können wir in Julia auch `Array`s konstruieren. Zunächst bastelt man sich eine range mittels `r Start Step Stop`, diese kann dann anschließend mittels `collect r ` zu einen `Array` umgeformt werden. Zum Beispiel hier die Erzeugung eines 1D `Array`s, dessen Elemente von 1 bis 19 mit einer Schrittweite von 3 reichen. \"\"\" arr collect 1 3 19 md\" Auch ein haüfiges Szenario Wir kennen den `Start` und `Stop` eines equidistanten Gitters, aber nicht die Schrittweite sondern nur die Länge des `Array`s. Sicherlich könnte man dann die Schrittweite errechnen, einfacher ist es jedoch den `range ` Befehl zu nutzen. Hier z.B. ein equidistantes Gitter von 1 bis 12, welches 7 Elemente beherbergt. \" arr2 collect range 1, 12, length 7 md\" Broadcasting Funktionen auf `Array`s anwenden \" md\" Sagen wir, wir haben ein 1D `Array` namens `zahlen`. Von jeden Element in `zahlen` möchten wir das Quadrat bilden und anschließend minus eins rechnen. \" zahlen collect 1 10 md\" Also basteln wir uns eine Funktion namens `quadrat minus eins` die eine Variable `d` einliest, diese quadriert und anschließend minus Eins rechnet. \" function quadrat minus eins d return d^2 1 end md\" Wenn wir nun versuchen das gesamte `Array` zahlen der Funktion zu übergeben bekommen wir einen Error, da die Funktion davon ausgeht, dass sie nur ein einziges Element bekommt und nicht ein ganzes `Array`. \" quadrat minus eins zahlen md\" Genauer formuliert bekommen wir einen Fehler, da der Potenzoperator `^` nicht weiß, wie er mit einen Vektor bzw. einen 1D `array` umzugehen hat. Um dieses Problem zu lösen müssen wir der Funktion mitteilen, dass sie jedes Element des `Array`s zahlen einzeln einlesen und verarbeiten soll. In Julia auch in MATLAB wird dies durch ein Punkt `.` zwischen Funktionsname und den runden Klammern kenntlich gemacht. \" vals quadrat minus eins. zahlen md\"Allgmein spricht man hier von der sogenannten Broadcast Syntax.\" md\" Beispiel Sinus Array Bauen wir ein feines Gitter mit der Schrittweite 0.01, welches sich von 0 bis 2π ersteckt. Anschließend wollen wir den Sinus an jeden Gitterpunkt ausrechnen. \" args collect 0. 0.01 2π md\"Nun rechnen wir an jeden Gitterpunkt den sin aus \" y sin. args md\" Das dies wirklich der Sinus ist, müsst ihr mir bis hierhin glauben. Eine grafische Darstellung ist im Plots Kapitel zu sehen. \" md\"\"\" Beispiel Multiplikation & Addition \"\"\" md\" Um zwei Vektoren elemtweise miteinander zu multiplizieren oder zu addieren benötigen wir ebenfalls die Broadcast Syntax mit einen Punkt `.` vor der Operation Funktion. \" let a 1, 2, 3 b 4, 5, 6 c a . b end md\" Hingegen das Skalarprodukt durch `dot a, b ` berechnet wird. Hierbei nutzen wir das oben geladene `LinearAlgebra` Paket. \" let a 1, 2, 3 b 4, 5, 6 c dot a, b end md\"Elementweise Addition \" let a 1, 2, 3 b 4, 5, 6 c a . b end md\" Längenmanipulation eines Arrays \" md\" Häufig möchten wir die Länge eines `Array` über die Zeit ändern, z.B. um ein Element ergänzen. In Julia kann man dies leicht durch die Befehle `push ` und `pop ` durchführen. Die Ausrufezeichen weißen dabei darauf hin, dass wir aktiv das `Array` verändern und keine Kopie erzeugen. \" md\" Verlängern\" md\" Erstellen von Array von 1 bis 10 \" q collect 1 10 md\"Anfügen engl. pushen von einen Element an letzter Stelle \" push q, 11 md\" Wie wir sehen haben wir q nachhaltig verändert \" q md\"Nun möchten wir noch eine 0 an erster Stelle anfügen, also `pushfirst ` \" pushfirst q, 0 md\" Verkürzen\" md\" Auf äquivalente Art und Weise können wir Arrays verkürzen und Elemente rausschmeisen engl. informatik pop . Auch hier wird hinten angefangen \" pop q q md\" Man kann aber auch vorne Elemente rausschmeissen, also `popfirst ` \" popfirst q q md\" 2D `Arrays`\" md\"\"\" 1D `Array`s werden schnell langweilig. Lasst uns nun 2D `Array`s anschauen, die sehr häufig benötigt werden. Ihr werdet feststellen das mit dem Vorwissen von 1D `Array`s der Sprung zu ND `Array`s nur minimal ist. Man kann auf ganz verschiedene Art und Weisen ein 2D `Array` bzw. eine Matrix erzeugen. Alle sind äquivalent \"\"\" M 1 2 3 4 M₂ 1 2 3 4 md\"\"\" Mittels Spaltenvektoren \"\"\" M₃ 1, 3 2, 4 typeof M md\"Die `2` im Typen bestätigt, dass es sich tatsächlich um ein 2D `Array` handelt\" md\"\"\" Die Navigation innerhalb eines 2D `Array`s ist identisch zum eindimensionalen Fall. Da wir nun in zwei Dimensionen arbeiten benötigen wir jedoch für die Position zwei `Indizes`. Der erste `Index` deklariert die Zeile in der wir arbeiten und der zweite `Index` die Spalte. `array row, column ` bzw. deutsch `array Zeile, Spalte ` \"\"\" M M 1, 1 M 2, 2 md\"\"\" Natürlich funktioniert auch hier slicing . \"\"\" M 1, 1 2 M 1 2, 2 md\"\"\" Auch hier können wir natürlich Werte ändern. \"\"\" M 1 2, 2 7, 7 M md\"\"\" Vorgefertigte Arrays \"\"\" md\"\"\" Für große Matrizen ist es wenig sinnvoll, diese per Hand zu definieren. Hier greift man auf bereits vorgefertigte Konstruktionen von Julia zurück. Z.B. können wir eine Matrix ein 2D `Array` voller Nullen durch den Befehl `zeros TYP, Anzahl Zeilen, Anzahl Spalten ` initialisieren. \"\"\" zeros 3, 5 md\"Wenn wir kein TYP angeben, so geht Julia davon aus das wir Gleitkommazahlen `Float64` meinen. Möchten wir hingegen ganze Zahlen `Integer` so können wir dies durch den TYP festlegen.\" einmaleins zeros Int64, 5, 5 md\"Jetzt könnte man mittels zweier in sich gekopppelter `for Schleifen` über die `Indizes` iterieren und somit die Matrix auffüllen. Hier z.B. eine 1×1 Tabelle bis 5 \" begin for zeilen idx in 1 5 for spalten idx in 1 5 einmaleins zeilen idx, spalten idx zeilen idx spalten idx end end einmaleins end md\"\"\" Das kleine 1×1 mittels array comprehension \"\"\" md\"Eine sehr nette und elegante Alternative ist abermals das array comprehension Muster. Hier das 1×1 bis 12 durch eine einzige Zeile Code.\" bigeinmaleins zeile spalte for zeile in 1 12, spalte in 1 12 md\"Natürlich gibt es noch viele andere vorgefertigte Arrays. Hier z.B. ein 2D `array` voller einsen, welches wir anschließend mittels Broadcasting der Multiplikation zu einen 2D `array` voller Sechsen verwandeln.\" einsen ones Int64, 6, 6 six 6 . einsen TableOfContents "},{"url":"week_0/basic_syntax/","title":"Variablen, Funktionen, Schleifen, Bedingungen","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.26 frontmatter chapter 1 order 1 title \"Variablen, Funktionen, Schleifen, Bedingungen\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils using PlutoUI md\" Erste Schritte in Julia ✋ Bevor Ihr hier anfangt, solltet Ihr vermutlich zunächst Julia installieren und das Package Pluto herunterladen. Eine genaue Anleitung findet Ihr weiter oben unter dem Reiter Software Installation . Ready? 🎬 Dann hier eine kleine Einführung \" md\"\"\" Variablen Wir können mithilfe des ` ` Zuweisungsoperators Variablen definieren. Dabei wird immer der linken Variablen der rechte Wert zugewiesen. Einmal festgelegt können wir dann die Größe Variable auch in anderen Zellen nutzen. \"\"\" x 3 y 2x md\"Standardmäßig zeigt Pluto Julia die Ausgabe über der ausgeführten Zelle an. Dies kann man beispielsweise durch ein Semikolon am Ende einer Zeile unterdrücken. \" md\"\"\" Um mehrere Zeilen ausführen zu können und dennoch die Variablen global in allen Zellen bereitzustellen, kann eine `begin ... end` Umgebung genutzt werden. \"\"\" begin h 2 p 3 k 3h 2p end k md\"\"\"Möchte man mehrere Zeilen hintereinander ausführen, aber die Sichtbarkeit der Variablen für andere Zellen beschränken so kann man eine `let ... end` Umgebung nutzen.\"\"\" let c 2 d 3 e 3c 2d end md\"\"\" Man definiert die Variablen also lokal in der Zelle `local scope` . Demnach erhalten wir nach Abfrage der Variablen `c` in einer anderen Zelle einen Error. \"\"\" c md\"Mithilfe von `typeof` können wir den Typen einer Variablen abfragen \" typeof y md\"\"\" In diesen Fall ist `y` eine 64Bit Integer Zahl. Es werden demnach 64 Binärzahlen bereitgestellt um die ganze Zahl darzustellen. Dazu eventuell an anderer Stelle mehr... \"\"\" md\" Funktionen\" md\"\"\" Häufig braucht man eine bestimmte Prozedur bestimmte Abfolge von Befehlen innerhalb eines Programms immer und immer wieder. Zur Förderung der Lesbarkeit des Codes, aber auch zur Verkürzung ist es dann ratsam Funktionen zu definieren. In Julia gibt es ganz verschiedene Möglichkeiten Funktionen zu deklarieren. Hier sind ein paar aufgezeigt, die alle identisch sind \"\"\" f₁ x 2 x f₂ x x 2 x function f₃ x return 2 x end md\"Um eine Funktion aufzurufen und an einer Stelle auszuwerten müssen wir runde Klammern ` ` nutzen.\" f₁ 10 md\"Für längere Funktionen sollte man die Syntax mit den `function` und `end` keyword nutzen. Außerdem kann man natürlich multivariable Funktionen definieren.\" function g x, y z x y return z^2 end g 1, 2 md\" For loops For Schleifen\" md\"\"\" Nutze `for` zum iterieren über ein `Iterator` `Array` `Range` und dessen Variablen. \"\"\" let Dies ist ein Kommentar Kennzeichunng mittels s 0 Summation aller Zahlen von 1 bis 10 for i in 1 10 s i Äquivalent zu s s i end s end md\"Hier ist `1 10` eine range welche die Zahlen von 1 bis 10 repräsentiert.\" typeof 1 10 md\"\"\" Wir haben gerade einen `let` Block genutzt um eine Variable `s` zu definieren. Dabei wäre es hier angebracht gewesen eine Funktion `mysum` zu schreiben, welche dann `global` in allen Zellen dieses Notebooks ausgeführt werden kann \"\"\" function mysum n s 0 for i in 1 n s i end return s end md\"\"\" Jetzt können wir die Funktion in einer anderen Zelle aufrufen. Zum Beispiel können wir die ersten 100 natürlichen Zahlen aufsummieren \"\"\" mysum 100 md\" Conditionals `if` Bedingungen `if`\" md\"\"\" Wir können auswerten ob eine Bedingung `true` oder `false` ist \"\"\" a 3 a 5 typeof a 5 md\"\"\" Wir sehen, dass Bedingungen einen `Bool` Ausgabetypen `true` oder `false` besitzen. Basierend auf der boolschen Ausgabe einer Bedingung können wir den Ablauf des Codes mit einer `if` `else` `end` Umgebung lenken. \"\"\" if a 5 \"small\" else \"big\" end md\"\"\" Falls diese Verzweigung auch noch nicht genügt, kann man eine `if elseif else end` Umgebung basteln. \"\"\" if a 2 \"small\" elseif a 2 && a 4 \"intermediate\" else a 4 \"big\" end md\"\"\" Hierbei haben wir Gebrauch von den `&&` Vergleichsoperator gemacht. Dieser vergleicht zwei boolsche Bedingungen links und rechts vom Operator . Sind beide wahr `true` , so ist die Ausgabe abermals `true`. Generell kann man sogar mehrere `elseif` Abfragen in einen solcher Umgebung unterbringen. \"\"\" md\" Logische Verknüpfungen Vergleichsoperatoren \" md\" Wie in jeder Programmiersprache existieren auch in Julia neben den logischen Und `&&` andere Vergleichsoperatoren. Zum Beispiel, das logische oder `||` oder die Negation ` `. Hier eine Reihe an Beispielen für die logischen Verknüpfungen \" let a true b false println \"Logisches Und \" println a&&b println a&&a println b&&b println \"Logisches Oder \" println a||b println a||a println b||b println \"Negation \" println a println b end md\" Mihilfe von Bedingungen können wir nun auch noch eine andere Art und Weise einführen Schleifen zu konstruieren. \" md\"\"\" While loops While Schleifen \"\"\" md\" While Schleifen laufen solange bis sie eine Abbruchbedingung erreichen. Dies macht Sie um einiges gefährlicher als eine `For` Schleife, da Sie eventuell nie Ihre Abbruchbedingung erzielen und somit ewig laufen. \" let i 0 while i 5 Ausgabe einer Zeile. Das Zeichen wertet die Variable in den runden Klammern aus und führt es in ein `String` über println \"i ist i und damit kleiner als 5\" i i 1 end end TableOfContents "},{"url":"week_0/plots/","title":"Plots in Julia","tags":["preliminaries"],"text":" A Pluto.jl notebook v0.19.26 frontmatter chapter 3 section 3 order 3 title \"Plots in Julia\" layout \"layout.jlhtml\" tags \"preliminaries\" description \"\" using Markdown using InteractiveUtils using CairoMakie, LinearAlgebra let using Makie.FileIO, MeshIO f Figure backgroundcolor RGBf 0.98, 0.98, 0.98 , resolution 1000, 700 ga f 1, 1 GridLayout gb f 2, 1 GridLayout gcd f 1 2, 2 GridLayout gc gcd 1, 1 GridLayout gd gcd 2, 1 GridLayout axtop Axis ga 1, 1 axmain Axis ga 2, 1 , xlabel \"before\", ylabel \"after\" axright Axis ga 2, 2 linkyaxes axmain, axright linkxaxes axmain, axtop labels \"treatment\", \"placebo\", \"control\" data randn 3, 100, 2 . 1, 3, 5 for label, col in zip labels, eachslice data, dims 1 scatter axmain, col, label label density axtop, col , 1 density axright, col , 2 , direction y end ylims axtop, low 0 xlims axright, low 0 axmain.xticks 0 3 9 axtop.xticks 0 3 9 leg Legend ga 1, 2 , axmain hidedecorations axtop, grid false hidedecorations axright, grid false leg.tellheight true colgap ga, 10 rowgap ga, 10 Label ga 1, 1 2, Top , \"Stimulus ratings\", valign bottom, font bold, padding 0, 0, 5, 0 xs LinRange 0.5, 6, 50 ys LinRange 0.5, 6, 50 data1 sin x^1.5 cos y^0.5 for x in xs, y in ys . 0.1 . randn. data2 sin x^0.8 cos y^1.5 for x in xs, y in ys . 0.1 . randn. ax1, hm contourf gb 1, 1 , xs, ys, data1, levels 6 ax1.title \"Histological analysis\" contour ax1, xs, ys, data1, levels 5, color black hidexdecorations ax1 ax2, hm2 contourf gb 2, 1 , xs, ys, data2, levels 6 contour ax2, xs, ys, data2, levels 5, color black cb Colorbar gb 1 2, 2 , hm, label \"cell group\" low, high extrema data1 edges range low, high, length 7 centers edges 1 6 . edges 2 7 . 0.5 cb.ticks centers, string. 1 6 cb.alignmode Mixed right 0 colgap gb, 10 rowgap gb, 10 brain load assetpath \"brain.stl\" ax3d Axis3 gc 1, 1 , title \"Brain activation\" m mesh ax3d, brain, color tri 1 2 for tri in brain for i in 1 3 , colormap Reverse magma , Colorbar gc 1, 2 , m, label \"BOLD level\" axs Axis gd row, col for row in 1 3, col in 1 2 hidedecorations . axs, grid false, label false for row in 1 3, col in 1 2 xrange col 1 ? 0 0.1 6pi 0 0.1 10pi eeg sum sin pi rand k x k for k in 1 10 for x in xrange . 0.1 . randn. lines axs row, col , eeg, color black, 0.5 end axs 3, 1 .xlabel \"Day 1\" axs 3, 2 .xlabel \"Day 2\" Label gd 1, , Top , \"EEG traces\", valign bottom, font bold, padding 0, 0, 5, 0 rowgap gd, 10 colgap gd, 10 for i, label in enumerate \"sleep\", \"awake\", \"test\" Box gd i, 3 , color gray90 Label gd i, 3 , label, rotation pi 2, tellheight false end colgap gd, 2, 0 n day 1 length 0 0.1 6pi n day 2 length 0 0.1 10pi colsize gd, 1, Auto n day 1 colsize gd, 2, Auto n day 2 for label, layout in zip \"A\", \"B\", \"C\", \"D\" , ga, gb, gc, gd Label layout 1, 1, TopLeft , label, fontsize 26, font bold, padding 0, 5, 5, 0 , halign right end colsize f.layout, 1, Auto 0.5 rowsize gcd, 1, Auto 1.5 f end using PlutoUI md\" Plots \" md\"\"\" Generell gibt es verschiedene `Packages` auch `libraries` oder in deutsch `Pakete` die es uns erlauben `Array`s zu visualisieren. In anderen Worten wir können mittels Paketen uns schicke Graphen von Funktionen etc. erzeugen. In diesem Kurs nutzen wir das Paket Makie.jl bzw. genauer CairoMakie. Als erstes Laden wir das Paket mittels `using CairoMakie` \"\"\" md\"\"\" Als nächstes legen wir fest, was für ein Ausgabetypen die Grafiken haben sollen. Hier wählen wir `svg`, demnach erstellen wir Vektorgrafiken die stechend scharf sind. Bei großen Bildern sollte man zu `png` wechseln, da die Vektorgrafik sonst zu groß wird. \"\"\" CairoMakie.activate type \"svg\" md\" Motivation \" md\" Zum Auswerten von Daten, aber auch für die Intuitionsentwicklung komplexer Sachverhalte ist es äußerst angebracht Visualierungen zu erzeugen. Mit Julia und dem Makie Package mit CairoMakie als Backend ist es sehr leicht möglich sehr komplizierte Daten auszuwerten und Grafiken für Publikationen zu erstellen. Hier ein Beipiel was alles mit Julia und dem Makie Package so möglich ist \" md\" Eure Aufgabe ist es natürlich nicht solch komplexe Plots bzw. Grafiken am Ende des Kurses erstellen zu können. Vielmehr soll hier eine Einführung stattfinden, nach der Ihr einfache Plots erzeugen könnt, aber auch einen Einblick bekommt wie weitaus komplizitiere Grafiken kreiert werden können. Zu diesen Punkt kommen wir als Erstes. Sollte euch das überhaupt gar nicht interessieren könnt ihr direkt zu den Minimalbeispielen springen versteht dann aber wahrscheinlich nicht, was die einzelnen Zeilen bewerkstelligen, da man etwas Hintergrundwissen benötigt. \" md\" Wie baut man Graphen? \" md\" Die Antwort im Makie Paket ist Stück für Stück wie im echten Leben. Zunächst braucht man eine Leinwand bzw. eine Figur engl. Figure auf der man zeichnen möchte. Eine solche Figur können wir durch den Befehl `Figure ` erstellen. Innerhalb der runden Klammern können wir Optionen festlegen, wie z.B. die Resolution Größe und die Hintergrundfarbe. Aus Demonstrationgründen wähle ich hier eine `moccasin`e Hintergrundfarbe für die Leinwand. \" Leinwand Figure resolution 1200, 800 , backgroundcolor moccasin, fontsize 23 md\" Nun haben wir ein Objekt Variable `Leinwand` auf der wir eine Achse engl. Axis bzw. Koordinatensystem zeichnen möchten. Dies können wir gewährleisten durch den `Axis Leinwand Zeile, Spalte , Optionen.. ` Befehl. Die Angabe einer Zeile und Spalte mag zunächst verwirren ist aber notwendig um die Position der `Axis` bzw. Koordinatensystem auf der `Figure` bzw. Leinwand festzulegen. Man kann sich die Leinwand also wie ein 2D `array` vorstellen. Positionen auf der Leinwand an der wir arbeiten wollen müssen wir also durch die Angabe von `Indizes` definieren. Wir nennen unser `Axis` Objekt hier Achse man kann es nennen wie man möchte . Wie wir sehen passt sich die Größe der `Axis` automatisch der Leinwand an. \" begin Achse Axis Leinwand 1, 1 , title \"Erste Achse\" Für die Anzeige der Grafik müssen wir erneut das `Figure Objekt` hier Leinwand aufrufen Leinwand end md\"\"\" Jetzt können wir in unsere Achse Axis unsere Daten hineinzeichnen. Die Größe der Achse wird sich automatisch den Daten und der Leinwand anpassen. Hier plotten wir zwei 1D `array`s, welche jeweils ein Sinus und einen invertierten Sinus darstellen. Wir möchten beide `Array`s in ein gemeinsames Koordinatensystem visualisieren. Dies geschieht durch den Linienplot Befehl `lines Achse, x, y `. Das Ausrufezeichen ` ` zeigt dabei, dass wir aktiv das Achsenobjekt `Achse` verändern wir zeichnen darauf . \"\"\" begin x collect 0 0.01 2π y sin. x lines Achse, x, y lines Achse, x, y Leinwand end md\" Man stelle sich nun vor wir möchten rechts neben dem Koordinatensystem `Achse` ein weiteres Koordinatensystem `Achserechts` platzieren. Im echten Leben wäre das natürlich ein Problem, denn wir haben keine freie Leinwand mehr. In Makie bzw. CairoMakie ist das kein Problem. Die Koordinatensysteme werden so skaliert, dass beide auf die Leinwand passen. Aber wie kreiere ich nun ein weiteres Koordinatensystem rechts? Wie bereits erwähnt verhält sich das `Figure` objekt wie ein 2D `Array`. Wir können also einfach mit dem Befehl `Achserechs Axis Leinwand 1, 2 , optionen.. ` so tun, als hätte die Leinwand zwei Spalten. Makie bzw. CairoMakie erstellt uns dann diese zweite Spalte. Nun können wir wieder mit den `lines ` und der Angabe des richtigen Koordinatensystems auf der rechten Achse zeichnen. Außerdem sind wir diesmal etwas genauer und geben unseren Linienplot ein `label` welches anschließend in `axislegend position lt ` benutzt wird um eine Legende oben links lt left top auf der Achse zu positionieren. \" begin Achserechts Axis Leinwand 1, 2 , title \"Zweite Achse\" g exp. x lines Achserechts, x, g, label \"Exponentialfunktion\", color red axislegend position lt Leinwand end md\"\"\" Erinnerst zu dich noch an der Array Slicing Syntax? Wie bereits erwähnt, verhält sich die Leinwand wie ein 2D `array`. Lasst uns also eine 2 te Zeile innerhalb der Leinwand kreieren und ein Koordinatensystem produzieren, welches sich über beide Spalten erstreckt. Dies können wir durch den Befehl `Axis Leinwand 2, 1 2 , optionen.. ` durchführen. Innerhalb der Optionen legen wir außerdem xy Achsenbeschriftung mit `xlabel \"x\"` bzw. `ylabel \"y\"` fest. Außerdem ändern wir die Skalierung der x und y Achse des Koordiantensystems `Achseunten` zu einer logarithmischen Skala. Innerhalb des `lines ` Funktionen führen wir auch Attribute für das Aussehen ein. \"\"\" begin Achseunten Axis Leinwand 2, 1 2 , title \"Dritte Achse Log Log Plot\", xlabel \"x\", ylabel \"f x \", yscale log10, xscale log10 lx collect 0.01 0.1 40 h lx.^ 2 k lx.^ 3 lines Achseunten, lx, h, color black, linestyle dash, linewidth 2, label L\"x^2\" lines Achseunten, lx, k, color green, linestyle dashdot, linewidth 2, label L\"x^3\" axislegend L\"f x \", position lt Leinwand end md\" Ok genug Details, hier so ein paar Minimalbeispiele um mal eben schnell was zu plotten. \" md\"\"\" Minimalbeispiel 4 Zeiler \"\"\" let 2 Arrays die gleich lang sind x collect 0 0.01 5 y cos. x . sin. 2x fig Figure resolution 800, 400 ax Axis fig 1, 1 lines ax, x, y fig end md\"\"\" Minimalbeispiel mit Achsenbeschriftung, Legende, multiple Graphen \"\"\" let Arrays die gleich lang sind x collect 0 0.01 5 y cos. x . sin. 2x z sin. x fig Figure resolution 800, 400 ax Axis fig 1, 1 , xlabel \"x\", ylabel \"f x \" lines ax, x, y, label \"Eine tolle Funktion\" lines ax, x, z, label \"Eine andere Funktion\" axislegend fig end md\"\"\" Minimalbeispiel mit \\LaTeX \"\"\" md\"\"\" Häufig ist es schöner eine \\LaTeX Formatierung für die Labels zu nutzen. Dies kann einfach durch ein `L` vor dem String Typen ausgedrückt werden. Z.B. `L\"f x \"`. Natürlich sind auch andere \\LaTeX Befehle abrufbar. Falls ihr noch nie etwas über \\LaTeX gehört habt, keine Sorge Ihr werdet es im Laufe des Studiums garantiert noch beigebracht bekommen und lieben lernen Microsoft Word is eine Pest für die Wissenschaft . \"\"\" let x collect 0 0.05 4π fig Figure resolution 800, 400 ax Axis fig 1, 1 , xlabel L\"x\", ylabel L\"f x \" Man kann als zweites Array auch eine Funktion mittels \"x f x \" übergeben aus der sich das zweite Array aus dem ersten hier x ergibt lines ax, x, x sin 3x cos x 2 x, label L\"\\frac \\sin 3x x \\cos x 2 \" lines ax, x, x cos x x, label L\"\\cos x x\" lines ax, x, x exp x , label L\"e^ x \" axislegend L\"f x \" position rt fig end md\"\"\" 3D Plots \"\"\" md\" Für dreidimensionale Grafiken benötigen wir einen anderen Achsentypen im echten Leben würden wir ja auch ein anderes Koordinatensystem benötigen . Im Makie Paket können wir durch die Funktion `Axis3 .. ` einen 3D Achsenobjekt erzeugen auf den wir anschließend wieder mit anderen Funktionen zeichnen können. Hier z.B. ein `wireframe` oder ein `surface` Plot der Funktion z x,y \\cos x \\sin y Dabei erzeugen wir zunächst ein äquidistantes Gitter für `x` und `y` und werten anschließend mittels array comprehension die Funktionswerte z x, y auf diesen aus. \" let CairoMakie.activate type \"svg\" x collect 0 0.02 2π y collect 0 0.02 2π z cos x elem sin y elem for x elem in x, y elem in y fig Figure resolution 1200, 600 ax3w Axis3 fig 1, 1 Für den wireframe plot nehmen wir jedes 10te Element innerhalb der Arrays, damit die Gitterlinien nicht so dicht aneinander kleben wireframe ax3w, x 1 10 end , y 1 10 end , z 1 10 end, 1 10 end , color black ax3 Axis3 fig 1, 2 surface ax3, x, y, z, colormap berlin fig end md\" Heatmaps & Contours \" md\" 3D Plots sehen zwar sehr eindrucksvoll aus und können sehr gut das qualitative Verhalten von Daten darstellen, jedoch kann man Datenpunkte nicht wirklich ablesen. Aus diesen Grund betrachtet man häufig `heatmap`s oder Höhenlinien Konturen engl. `contour` von 3D Plots, die dann wieder in zwei Dimensionen dargestellt werden können. \" let CairoMakie.activate type \"png\" x collect 0 0.02 2π y collect 0 0.02 2π z cos x elem sin y elem for x elem in x, y elem in y fig Figure resolution 800, 700 , fontsize 24 ax Axis fig 1, 1 , xlabel L\"x\", ylabel L\"y\" heat heatmap ax, x, y, z, colormap berlin contour ax, x, y, z, color white, levels 15 farbbar Colorbar fig 1,2 , heat, ticks 1 0.2 1, label L\"z\" fig end md\" More Advanced \" md\"\"\" Der Fantasie sind generell keine Grenzen gesetzt. Hier seht ihr z.B. ein Programm welches elektrische Feldlinien für einen Dipol und ein Quadrupol plottet. Die Farben der Linien deuten die Stärke Norm der Länge des elektrischen Feldes an rot stark zu schwarz schwach . Rote Punkte sind positive Ladungen, blaue negative Ladungen. \"\"\" let CairoMakie.activate type \"png\" function E q, rx, ry, x, y d sqrt x rx ^2 y ry ^2 ^3 return q x rx d, q y ry d end function charges nq 2 qs for i in 1 nq q i % 2 2 1 push qs, q, cos 2π i nq , sin 2π i nq end qs end function fieldE x,y Ex, Ey 0, 0 for q in qs ex, ey E q..., x, y Ex ex Ey ey end Point Ex, Ey end Erstellen einer Figur und der Achsen Axis auf denen wir zeichnen möchten. fig Figure resolution 1200,800 , fontsize 25 ax1 Axis fig 1,1 aspect DataAspect , title \"Feldlinien Dipol\", xgridvisible false, ygridvisible false ax2 Axis fig 1,2 aspect DataAspect , title \"Feldlinien Quadrupol\", xgridvisible false, ygridvisible false Dipol Axis qs charges streamplot ax1, fieldE, 2..2, 2..2 arrow size 12, linewidth 2.5, colorrange 3,3 , colormap berlin Array comprehension um Ladungen zu plotten scatter ax1, Point qs i 2 3 , color qs i 1 0 ? red dodgerblue, markersize 20 for i in eachindex qs limits ax1, 2,2, 2,2 Quadrupol Axis qs charges nq 4 streamplot ax2, fieldE, 2..2, 2..2 arrow size 12, linewidth 2.5, colorrange 3,3 , colormap berlin scatter ax2, Point qs i 2 3 , color qs i 1 0 ? red dodgerblue, markersize 20 for i in eachindex qs limits ax2, 2,2, 2,2 hidedecorations ax1 grid false hidedecorations ax2 grid false fig end TableOfContents "},{"url":"week_1/assignment_1/","title":"Aufgabenblatt 1","tags":["assignments"],"text":" A Pluto.jl notebook v0.19.26 frontmatter order 1 title \"Aufgabenblatt 1\" layout \"layout.jlhtml\" description \"\" tags \"assignments\" using Markdown using InteractiveUtils using LinearAlgebra md\"\"\" Aufgabenblatt für Woche 1 \"\"\" a 2 1 2 3 4 I "},{"url":"week_1/lecture_1/","title":"Vorlesung 1","tags":["lecs"],"text":" A Pluto.jl notebook v0.19.26 frontmatter order 1 title \"Vorlesung 1\" layout \"layout.jlhtml\" description \"\" tags \"lecs\" using Markdown using InteractiveUtils md\"\"\" Vorlesung 1 \"\"\" \"Hi 🤝\" "}]